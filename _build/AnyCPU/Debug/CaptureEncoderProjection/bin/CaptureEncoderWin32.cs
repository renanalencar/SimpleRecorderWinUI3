//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 2.0.7.240207.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace CaptureEncoderWin32
{
    [global::WinRT.WindowsRuntimeType("CaptureEncoderWin32")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.CaptureEncoderWin32.Class))]
    [global::WinRT.ProjectedRuntimeClass(typeof(IClass))]
    [global::WinRT.ObjectReferenceWrapper(nameof(_inner))]
    public sealed class Class : global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<Class>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__CaptureEncoderWin32_IClass => _inner;


        private static volatile FactoryObjectReference<IActivationFactoryVftbl> ___objRef_global__CaptureEncoderWin32_Class;
        private static FactoryObjectReference<IActivationFactoryVftbl> _objRef_global__CaptureEncoderWin32_Class
        {
            get
            { 
                var factory = ___objRef_global__CaptureEncoderWin32_Class;
                if (factory != null && factory.IsObjectInContext())
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__CaptureEncoderWin32_Class = ActivationFactory.Get("CaptureEncoderWin32.Class");
                }
            }
        }

        public Class() : this((global::WinRT.IActivationFactoryMethods.ActivateInstance<IUnknownVftbl>(_objRef_global__CaptureEncoderWin32_Class)))
        {
            ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
            ComWrappersHelper.Init(_inner, false);
        }

        public static Class FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<Class>.FromAbi(thisPtr);
        }

        internal Class(IObjectReference objRef)
        {
            _inner = objRef.As(GuidGenerator.GetIID(typeof(IClass).GetHelperType()));

        }

        public static bool operator ==(Class x, Class y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(Class x, Class y) => !(x == y);
        public bool Equals(Class other) => this == other;
        public override bool Equals(object obj) => obj is Class that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public int MyProperty
        {
            get => global::ABI.CaptureEncoderWin32.IClassMethods.get_MyProperty(_objRef_global__CaptureEncoderWin32_IClass);
            set => global::ABI.CaptureEncoderWin32.IClassMethods.set_MyProperty(_objRef_global__CaptureEncoderWin32_IClass, value);
        }

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.InterfaceIIDs.IInspectable_IID == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("CaptureEncoderWin32")][Guid("DCBBCB43-9FBC-5FBF-9F50-CA205C9646CB")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.CaptureEncoderWin32.IClass))]
    internal interface IClass
    {
        int MyProperty { get; set; }
    }
}

#pragma warning disable CA1416
namespace ABI.CaptureEncoderWin32
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct Class
    {

        public static IObjectReference CreateMarshaler(global::CaptureEncoderWin32.Class obj) => obj is null ? null : MarshalInspectable<global::CaptureEncoderWin32.Class>.CreateMarshaler<IUnknownVftbl>(obj, GuidGenerator.GetIID(typeof(global::CaptureEncoderWin32.IClass).GetHelperType()));
        public static ObjectReferenceValue CreateMarshaler2(global::CaptureEncoderWin32.Class obj) => MarshalInspectable<object>.CreateMarshaler2(obj, GuidGenerator.GetIID(typeof(global::CaptureEncoderWin32.IClass).GetHelperType()));
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::CaptureEncoderWin32.Class FromAbi(IntPtr thisPtr) => global::CaptureEncoderWin32.Class.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::CaptureEncoderWin32.Class obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.MarshalerArray CreateMarshalerArray(global::CaptureEncoderWin32.Class[] array) => MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.GetAbiArray(box);
        public static unsafe global::CaptureEncoderWin32.Class[] FromAbiArray(object box) => MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.FromAbiArray(box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::CaptureEncoderWin32.Class[] array) => MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.MarshalerArray array) => MarshalInterfaceHelper<global::CaptureEncoderWin32.Class>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    internal static class IClassMethods
    {
        internal static global::System.Guid IID { get; } = new Guid(new global::System.ReadOnlySpan<byte>(new byte[] { 0x43, 0xCB, 0xBB, 0xDC, 0xBC, 0x9F, 0xBF, 0x5F, 0x9F, 0x50, 0xCA, 0x20, 0x5C, 0x96, 0x46, 0xCB }));

        public static unsafe int get_MyProperty(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            int __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, out int, int>**)ThisPtr)[6](ThisPtr, out __retval));
            return __retval;
        }
        public static unsafe void set_MyProperty(IObjectReference _obj, int value)
        {
            var ThisPtr = _obj.ThisPtr;

            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, int>**)ThisPtr)[7](ThisPtr, value));
        }


    }
    [Guid("DCBBCB43-9FBC-5FBF-9F50-CA205C9646CB")]
    internal interface IClass : global::CaptureEncoderWin32.IClass
    {
    }
}
#pragma warning restore CA1416
